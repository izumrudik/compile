#!lang.py -r
include "std.lang"
const ROWS 10
const COLS 25

const CELL_EMPTY 0
const CELL_APPLE   1
const CELL_SNAKE 2

struct Point {
	x:int
	y:int
}

fun savePoint p:ptr(Point) x:int y:int {
	save(p.x, x)
	save(p.y, y)
}
extend save with savePoint

const DIR_UP    0
const DIR_DOWN  1
const DIR_LEFT  2
const DIR_RIGHT 3

var score int
var head_dir int
var head_pos Point
var input char
const SNAKE_CAP ROWS * COLS
var snake [SNAKE_CAP]Point
var snake_begin int
var snake_size  int
var cells [COLS][ROWS]int #@enum


fun display {
	y:int
	x:int
	cell:int
	puts("Score: ")
	putd(load(score))
	puts("\n")
	x = 0
	y = 0
	while y < ROWS {
		x = 0
		while x < COLS {
			cell = load(cells[x][y])
			if cell == CELL_EMPTY {
				puts('.')
			} elif cell == CELL_APPLE {
				puts("*")
			} elif cell == CELL_SNAKE {
				if x == load(head_pos.x) and y == load(head_pos.y) {
					puts('S')
				} else {
					puts('#')
				}
			} else {
				eputs("\nAssertion Failed: unreachable\n")
				exit(1)
			}
			x = x + 1
		}
		puts("\n")
		y = y+1
	}
	puts("WASD to move, Q to quit\n")
}

fun step_point p:ptr(Point) dir:int {
	x:int = load(p.x)+1#+1, to avoid implementing negative numbers
	y:int = load(p.y)+1
	    if dir == DIR_UP    { y=y-1
	} elif dir == DIR_DOWN  { y=y+1
	} elif dir == DIR_LEFT  { x=x-1
	} elif dir == DIR_RIGHT { x=x+1
	}

	x = x % COLS
	y = y % ROWS
	if x == 0 {x = COLS}
	if y == 0 {y = ROWS}

	save(p,x-1,y-1)
}

fun spawn_snake x:int y:int dir:int len:int {
	save(head_pos,x,y)
	save(head_dir,dir)
	snake_add(x,y)
	idx:int = 1
	while idx < len {
		step_point(head_pos,load(head_dir))

		snake_add(load(head_pos.x),load(head_pos.y))
		idx = idx + 1
	}
}

fun snake_add x:int y:int {

	if load(snake_size) >= SNAKE_CAP {
		putsln("\nYOU WON!!!")
		exit(0)
	}

    save(cells[x][y], CELL_SNAKE)

    save(snake[(load(snake_begin) + load(snake_size)) % SNAKE_CAP], x, y)

    save(snake_size,load(snake_size)+1)
}
fun snake_del {
	p:ptr(Point) = snake[load(snake_begin)]
	x:int = load(p.x)
	y:int = load(p.y)
	save(cells[x][y],CELL_EMPTY)

	save(snake_size,load(snake_size)-1)

	save(snake_begin,(load(snake_begin)+1) % SNAKE_CAP)
}

fun spawn_apple {

	x:int = (rand() << 30) % COLS
	y:int = (rand() << 30) % ROWS
	while load(cells[x][y]) != CELL_EMPTY {
		x = (rand() << 30) % COLS
		y = (rand() << 30) % ROWS
	}
	save(cells[x][y], CELL_APPLE)
}
var saved_tio Termios
var tio Termios
var delta_time Timespec
fun main {
,	display()
	quit:bool = False

	#configure stdin to read without `enter`
	tcgetattr(stdin,$ptr()(saved_tio))
	tcgetattr(stdin,$ptr()(tio))
	flag:ptr(short) = tio.c_lflag
	save(flag, $short(!(ICANON or ECHO)) and load(flag))
	save((tio.c_cc[VMIN]), 1c)
	save((tio.c_cc[VTIME]),0c)
	tcsetattr(stdin, TCSAFLUSH, $ptr()(tio))

	# configure to be non-blocking
	arg:int = fd_getfl(stdin)
	arg = arg or O_NONBLOCK
	fd_setfl(stdin, arg)

	#configure timer
	save(delta_time,0,250_000_000)

	spawn_snake(5,5,DIR_RIGHT,3)
	spawn_apple()
	#game loop
	while !quit {
		puts('\x1b[');putd(ROWS+2);puts('A')#TODO: need a simple way to display any char
		puts('\x1b[');putd(COLS);puts('D')
		display()
		read(stdin,input,1)
		cmd:char = load(input)
		dir:int = load(head_dir)
		if cmd == 'q'c {
			quit = True
        } elif cmd == 'w'c and dir != DIR_DOWN {
			save(head_dir,DIR_UP   )
        } elif cmd == 'a'c and dir != DIR_RIGHT {
			save(head_dir,DIR_LEFT )
		} elif cmd == 's'c and dir != DIR_UP {
			save(head_dir,DIR_DOWN )
        } elif cmd == 'd'c and dir != DIR_LEFT {
			save(head_dir,DIR_RIGHT)
		}


        step_point(head_pos,load(head_dir))
		cell:int = load(cells[load(head_pos.x)][load(head_pos.y)])
		if cell == CELL_SNAKE {
			putsln("\nYou Died with Score: ")
			putd(load(score))
			puts('\n')
			quit = True
		} elif cell == CELL_APPLE{
			snake_add(load(head_pos.x),load(head_pos.y))
            save(score,load(score)+1)
            spawn_apple()
		} elif cell == CELL_EMPTY{
            snake_del()
			snake_add(load(head_pos.x),load(head_pos.y))
		}
		#sleep
		if sleep(delta_time) != 0 {
			quit = True
			eputs("Timer went wrong")
		}
	}

	#quitting
	tcsetattr(stdin, TCSANOW, $ptr()(saved_tio))

}
fun str_to_ptr(string:str) -> *char { return $*char(string) }
mix ptr {
	str_to_ptr
}
fun len(string:str) -> int { return $int(string) }
fun str(length:int,pointer:*char) -> str {
	return $(length, pointer) 
}
fun char_to_int(c:char) -> int { return $int(c) }
fun short_to_int(s:short) -> int { return $int(s) }
mix int {
	char_to_int
	short_to_int
}

fun int_to_char(i:int) -> char { return $char(i) }
fun short_to_char(s:short) -> char { return $char(s) }
mix char {
	int_to_char
	short_to_char
}

fun int_to_short(i:int) -> short { return $short(i) }
fun char_to_short(c:char) -> short { return $short(c) }
mix short {
	int_to_short
	char_to_short
}
fun cstr_len(cstr:*[]char) -> int {
	i = 0
	while @cstr[@i] != 0c {i=@i+1}
	return @i
}
fun cstr_to_str(cstr:*[]char) -> str { return str(cstr_len(cstr), cstr[0]) }
fun get_arg (idx:int) -> str { return cstr_to_str(@Argv[idx]) }

fun nth_bit(a:int,n:int) -> int { return ((a >> n) and 1) }

use exit(int) -> void
use write(short, *char, int) -> void
use read(short,*char,int) -> int

const stdin  0
const stdout 1
const stderr 2

fun fputs(fd:int,string:str){ write(short(fd), ptr(string), len(string)) }
fun  puts(string:str){ fputs(stdout,string) }
fun eputs(string:str){ fputs(stderr,string) }

fun putch(ch:char) {
	c = ch
	puts(str(1,c))
}

fun putendl(){
	putch('\n'c)
}
fun putsln(string:str){
	puts(string)
	putendl()
}

fun putd(a:int) {
	if a < 10 {
		putch('0'c + char(a))
	} else {
		putd(a//10)
		putd(a%10)
	}
}

fun parse_int(s:str) -> int {
	idx = 0
	n = 0
	while @idx < len(s) {
		if s[@idx] >= '0'c and s[@idx] <= '9'c {
			n = @n * 10 + int(s[@idx] - '0'c)
		} else {
			putch("'"c)
			puts(s)
			puts("' is not a valid integer")
			exit(1)#@raise, @panic, @unwind
		}
		idx = @idx + 1
	}
	return @n
}


struct Array~%ArrayItem~ {
	__length:int
	__allocated:int
	__value:*[]%ArrayItem
	fun __init__(self:*Array~%ArrayItem~) {
		self.__length = 0
		self.__allocated = 0
		[0]x:%ArrayItem
		self.__value = x
	}
	fun getitem(self:*Array~%ArrayItem~, idx:int) -> *%ArrayItem {
		return (@self.__value)[idx]
	}
	fun append(self:*Array~%ArrayItem~, value:%ArrayItem) -> *Array~%ArrayItem~ {
		self.__length = @self.__length+1
		if @self.__allocated<@self.__length {
			self.__reallocate(@self.__allocated*9//8+1)
		}
		(@self.__value)[@self.__length-1] = value
		return self
	}
	fun __reallocate(self:*Array~%ArrayItem~,new_len:int) {
		[new_len]new_array:%ArrayItem
		idx = 0
		while @idx<@self.__allocated {
			new_array[@idx] = @(@self.__value)[@idx]
			idx=@idx+1
		}
		self.__allocated = new_len
		self.__value = new_array
	}
	fun length(self:*Array~%ArrayItem~) -> int {
		return @self.__length
	}
}

fun allocate~%AllocateType~(n:%AllocateType) -> *%AllocateType {
	x:%AllocateType=n
	return x
}
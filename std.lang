mix save {
	save_int
	save_char
	save_short
}

mix load {
	load_int
	load_char
	load_short
}

const stdin  0
const stdout 1
const stderr 2

fun puts string:str { write(stdout, string) }
fun eputs string:str { write(stderr, string) }
fun fputs fd:int string:str { write(fd, string) }
var __putch_char char
fun putch char:char {
	save(__putch_char,char)
	write(stdout, str(1,$ptr()(__putch_char)))
}
fun putendl {
	puts('\n')
}
fun putsln string:str {
	puts(string)
	putendl()
}

fun putd a:int{
	if a < 10 {
		putch('0'c + char(a))
	} else {
		putd(a//10)
		putd(a%10)
	}
}
#Timespec
struct Timespec {
        sec:int
        nsec:int
	fun sleep spec:ptr(Timespec) -> int {
		return nanosleep($ptr()(spec),Null)
	}
}

fun save_Timespec spec:ptr(Timespec) sec:int nsec:int {
        save(spec.sec, sec)
        save(spec.nsec, nsec)
}
extend save with save_Timespec



var __delay_local_spec Timespec
fun delay sec:int nsec:int -> int {
	save_Timespec(__delay_local_spec, sec, nsec)
	return __delay_local_spec.sleep()
}


#fcntl - manipulate file descriptor
const O_RDONLY   0o0
const O_WRONLY   0o1
const O_RDWR     0o2
const O_ACCMODE  0o3
const O_TRUNC    0o1000
const O_APPEND   0o2000
const O_NONBLOCK 0o4000

const F_SETFL 4
const F_GETFL 3
fun fd_getfl fd:int -> int{
	return fcntl(fd, F_GETFL, 0)#arg is ignored
}
fun fd_setfl fd:int arg:int -> int{
	return fcntl(fd, F_SETFL, arg)
}
#termios
const NCCS 32
struct Termios {
	c_iflag : short      # input mode flags
	c_oflag : short      # output mode flags
	c_cflag : short      # control mode flags
	c_lflag : short      # local mode flags
	c_line  : char       # line discipline
	c_cc    : [NCCS]char # control characters
	c_ispeed: short      # input speed
	c_ospeed: short      # output speed
}
const ICANON 0b10
const ECHO   0b1000

const VINTR 0
const VQUIT 1
const VERASE 2
const VKILL 3
const VEOF 4
const VTIME 5
const VMIN 6
const VSWTC 7
const VSTART 8
const VSTOP 9
const VSUSP 10
const VEOL 11
const VREPRINT 12
const VDISCARD 13
const VWERASE 14
const VLNEXT 15
const VEOL2 16

const TCSAFLUSH 2
const TCSANOW 0
fun get_tio fd:int tio:ptr(Termios) -> int {
	return tcgetattr(fd, $ptr()(tio))
}
fun set_tio fd:int mode:int tio:ptr(Termios) -> int {
	return tcsetattr(fd, mode, $ptr()(tio))
}
#std
fun noop {}

fun nth_bit a:int n:int -> int { return ((a >> n) and 1) }

var random_seed int
fun rand -> int {
    save(random_seed,(load(random_seed) * 0x41c64e6d + 12345) and 0x7fffffff)
    return load(random_seed);
}


fun cstr_len cstr:ptr([]char) -> int {
	i: int = 0
	while load_char(cstr[i]) != 0c {i=i+1}
	return i
}
fun cstr_to_str cstr:ptr([]char) -> str {
	return str(cstr_len(cstr), $ptr()(cstr))
}
fun get_arg idx:int -> str {
	return cstr_to_str($ptr([]char)(load_ptr($ptr(ptr)(Argv[idx]))))
}

fun char_to_int c:char -> int { return $int(c) }
fun short_to_int s:short -> int { return $int(s) }
mix int {
	char_to_int
	short_to_int
}

fun int_to_char i:int -> char { return $char(i) }
fun short_to_char s:short -> char { return $char(s) }
mix char {
	int_to_char
	short_to_char
}

fun int_to_short i:int -> short { return $short(i) }
fun char_to_short c:char -> short { return $short(c) }
mix short {
	int_to_short
	char_to_short
}

fun parse_int s:str -> int {
	idx = 0
	n = 0
	while idx < len(s) {
		if s[idx] >= '0'c and s[idx] <= '9'c {
			n = n * 10 + int(s[idx] - '0'c)
		} else {
			puts("'")
			puts(s)
			puts("'")
			puts(" is not a valid integer")
			exit(1)#@raise, @panic, @unwind
		}
		idx = idx + 1
	}
	return n
}

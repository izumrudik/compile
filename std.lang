
const stdin  0
const stdout 1
const stderr 2

use exit(int) -> void
use write(int, ptr(char), int) -> void
use read(int,ptr(char),int) -> int
use fcntl(int, int, int) -> int


fun fputs fd:int string:str { write(fd, ptr(string), len(string)) }
fun puts  string:str { fputs(stdout,string) }
fun eputs string:str { fputs(stderr,string) }

var __putch_char char
fun putch char:char {
	__putch_char <- char
	puts(str(1,__putch_char))
}

fun putendl {
	puts('\n')
}
fun putsln string:str {
	puts(string)
	putendl()
}

fun putd a:int{
	if a < 10 {
		putch('0'c + char(a))
	} else {
		putd(a//10)
		putd(a%10)
	}
}
#Timespec
struct Timespec {
        sec:int
        nsec:int
	fun sleep spec:ptr(Timespec) -> int {
		return nanosleep(spec,$ptr(Timespec)(Null))
	}
}
use nanosleep(ptr(Timespec), ptr(Timespec)) -> int


var __delay_local_spec Timespec
fun delay sec:int nsec:int -> int {
	__delay_local_spec.sec <- sec
	__delay_local_spec.sec <- nsec
	return __delay_local_spec.sleep()
}


#fcntl - manipulate file descriptor
const O_RDONLY   0o0
const O_WRONLY   0o1
const O_RDWR     0o2
const O_ACCMODE  0o3
const O_TRUNC    0o1000
const O_APPEND   0o2000
const O_NONBLOCK 0o4000

const F_SETFL 4
const F_GETFL 3
fun fd_getfl fd:int -> int{
	return fcntl(fd, F_GETFL, 0)#arg is ignored
}
fun fd_setfl fd:int arg:int -> int{
	return fcntl(fd, F_SETFL, arg)
}
#termios
const NCCS 32
struct Termios {
	c_iflag : short      # input mode flags
	c_oflag : short      # output mode flags
	c_cflag : short      # control mode flags
	c_lflag : short      # local mode flags
	c_line  : char       # line discipline
	c_cc    : [NCCS]char # control characters
	c_ispeed: short      # input speed
	c_ospeed: short      # output speed
}
use tcsetattr(int, int, ptr(Termios)) -> int
use tcgetattr(int, ptr(Termios)) -> int

const ICANON 0b10
const ECHO   0b1000

const VINTR 0
const VQUIT 1
const VERASE 2
const VKILL 3
const VEOF 4
const VTIME 5
const VMIN 6
const VSWTC 7
const VSTART 8
const VSTOP 9
const VSUSP 10
const VEOL 11
const VREPRINT 12
const VDISCARD 13
const VWERASE 14
const VLNEXT 15
const VEOL2 16

const TCSAFLUSH 2
const TCSANOW 0
fun get_tio fd:int tio:ptr(Termios) -> int {
	return tcgetattr(fd, tio)
}
fun set_tio fd:int mode:int tio:ptr(Termios) -> int {
	return tcsetattr(fd, mode, tio)
}
#std
fun noop {}

fun nth_bit a:int n:int -> int { return ((a >> n) and 1) }

var random_seed int
fun rand -> int {
    random_seed <- (@random_seed * 0x41c64e6d + 12345) and 0x7fffffff
    return @random_seed;
}


fun cstr_len cstr:ptr([]char) -> int {
	i: int = 0
	while @cstr[i] != 0c {i=i+1}
	return i
}
fun cstr_to_str cstr:ptr([]char) -> str {
	return str(cstr_len(cstr), cstr[0])
}
fun get_arg idx:int -> str {
	return cstr_to_str(@Argv[idx])
}

fun char_to_int c:char -> int { return $int(c) }
fun short_to_int s:short -> int { return $int(s) }
mix int {
	char_to_int
	short_to_int
}

fun int_to_char i:int -> char { return $char(i) }
fun short_to_char s:short -> char { return $char(s) }
mix char {
	int_to_char
	short_to_char
}

fun int_to_short i:int -> short { return $short(i) }
fun char_to_short c:char -> short { return $short(c) }
mix short {
	int_to_short
	char_to_short
}

fun parse_int s:str -> int {
	idx = 0
	n = 0
	while idx < len(s) {
		if s[idx] >= '0'c and s[idx] <= '9'c {
			n = n * 10 + int(s[idx] - '0'c)
		} else {
			puts("'")
			puts(s)
			puts("'")
			puts(" is not a valid integer")
			exit(1)#@raise, @panic, @unwind
		}
		idx = idx + 1
	}
	return n
}
